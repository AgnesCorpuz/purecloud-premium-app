.tutorial{:data =>{:title=>'Using Client App SDK and JavaScript PureCloud SDK'}}
    .step{:data=>{:title=>'Introduction'}}
        :markdown
			This tutorial walks through the steps how to integrate with PureCloud Client App SDK and JavaScript PureCloud SDK.
			
			Common configurations that need to be done includes creating URL Interpolation to determine pcLangTag and pcEnvironment and creating toast notifications for incoming calls.
            
            For this project, we are going to use the JavaScript PureCloud SDK and using JavaScript ES6 coding standards.
            
            Other requirements:
            * Creating a notification channel
			* Subscribe to call conversations of current user
			* Get active conversation in a queue
			* Subscribe to queue			
			* Get conversation details
			* Determine conversation type (call, chat, callback or email) and conversation status (on queue, alerting, connected or disconnected)

    .step{:data=>{:title=>'URL Interpolation to determine pcLangTag and pcEnvironment'}}
        :markdown
			Pre-Requisites:
			* The confiured app should have a URL defining the pcLangTag and pcEnvironment tags ex. https://myapp.com?langTag={{pcLangTag}}&environment={{pcEnvironment}}
		
			The pcLangTag will be used to determine which language the app will use for displays.
			The pcEnvironment will be used to determine which Client ID will be used for authentication.

    .step{:data=>{:title=>'Deep Dive on pcLangTag'}}
        :markdown
            Before the app loads, it needs to determine which language to be used for the HTML fields.
			
			This logic gets the locale of the current user. This value follows the bcp 74 pattern. Once the locale is determined, HTML fields will be populated accordingly.
			
	.step{:data=>{:title=>'Deep Dive on pcLangTag'}}
        :markdown
            A separate JSON file is configured to store language translations per HTML field. If the locale does not have the language specified in the JSON file, it will default to en-us.

    .step{:data=>{:title=>'Deep Dive on pcEnvironment for Authentication'}}
        :markdown
            Before we can start making PureCloud API calls, we need to determine the PureCloud environment that the app is running in ex. mypurecloud.com, mypurecloud.ie, etc. Different regions have different OAuth Client IDs so it must be determined before attempting to authenticate.
			
			Once the pcEnvironment is determined, we can pass the value to the JavaScript method for authentication.

    .step{:data=>{:title=>'Deep Dive on pcEnvironment for Authentication'}}
        :markdown
            A separate JavaScript file contains the object that holds the different Client IDs per region. We need to filter the object to get which Client ID to be used and call the loginImplicitGrant method of the Javascript PureCloud SDK. If the pcEnvironment is not set, it will default to mypurecloud.com region.

    .step{:data=>{:title=>'Creating Toast Notifications for Incoming Calls'}}
        :markdown
            Aside form URL Interpolation, the Client App SDK also has the capability to send toast messages.

    .step{:data=>{:title=>'Creating a Notification Channel and  Subscribing to Conversations'}}
        :markdown
            In order to send toast notifications for incoming calls, we need to create a channel and subscribe to call conversations of the current user.
			
			We need to use the JavaScript PureCloud SDK and call the postNotificationsChannels and the postNotificationsChannelSubscriptions of the Notifications API.

    .step{:data=>{:title=>'Handling Websocket Messages'}}
        :markdown
            For every websocket message the app receives, we need to determine if the Topic ID in the socket message matches the Topic ID we used in subscribing to the channel. Once the Topic ID has been validated, we can proceed in populating the widget app fields and call the method to send the toast message.

    .step{:data=>{:title=>'Calling Toast Popup in the Client App SDK'}}
        :markdown
            To show a toast popup in PureCloud, we need to call the showToastPopup method of the Alerting API on the Client App SDK passing the title, message and options as parameters.
			
	.step{:data=>{:title=>'Get Active Conversations in a Queue'}}
        :markdown
            In order to get active conversations in a queue, we need to use the postAnalyticsConversationsDetailsQuery of the Analytics API.
			
			If there are active conversations in the queue, the app will display the details in the standalone interaction.
			
			The body of the request should have a segment filter to match the Queue ID and a conversation filter to check if the Conversation End does not exist.
			
	.step{:data=>{:title=>'Get Active Conversations in a Queue'}}
        :markdown			
			The body of the request should have a segment filter to match the Queue ID and a conversation filter to check if the Conversation End does not exist.
			
	.step{:data=>{:title=>'Subscribing to Queue'}}
        :markdown
            In order to subscribe to a queue, we first need to create a notifications channel. Once we have established a notifications channel, we are now ready to call the postNotificationsChannleSubscriptions method of the Notifications API of the JavaScript PureCloud SDK.
			
			The Topic ID used in this project is "v2.routing.queues." + queue + ".conversations" where the queue parameter is the queueId.
			
	.step{:data=>{:title=>'Get Conversation Details'}}
        :markdown
            For every websocket message in the queue, the app needs to display conversation details in the standalone integration.
			
			If the conversation details are not yet displayed, a new row needs to be added in the table. If there is already a row in the view and another web socket message comes in for a scpecific Conversation ID, the row needs to be updated.
			
	.step{:data=>{:title=>'Determine Conversation Type'}}
        :markdown
            To determine the conversation type of the web socket message, we need to check if the calls, chats, callbacks or emails attribute in the participants object exists.
			
			The callback conversation type has both calls and callbacks attribute on the websocket message.
			
	.step{:data=>{:title=>'Determine Conversation Status'}}
        :markdown
            To determine the conversation status of the web socket message, we need to check for the following:
			
			On Queue - Participant attributes does not have an agent and ACD state is connected
			Alerting - Participant attributes has an agent and ACD does not have end time attribute
			Connected - Participant attributes has an agent, Customer does not have end time attribute and ACD has an end time
			Disconnected - Participant attributes has an agent and agent state is Disconnected